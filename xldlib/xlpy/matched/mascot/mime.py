'''
    XlPy/Matched/Protein_Prospector/mime
    ____________________________________

    Mascot's native data format (.dat files) is a MIME format, with data
    in sections that can easily be split to key-value pairs.

    :copyright: (c) 2015 The Regents of the University of California.
    :license: GNU GPL, see licenses/GNU GPLv3.txt for more details.
'''

# load future
from __future__ import print_function

# load modules
import ast
import copy
import sys

from xldlib.definitions import re, unquote
from xldlib.general import mapping, sequence
from xldlib.objects import matched
from xldlib.qt.objects import base
from xldlib.utils import decorators, logger, masstools

from .. import scan_titles, sequence_variants

# load objects/functions
from collections import OrderedDict
from email.parser import Parser

# This comprises a basic parser for the Mascot .dat file

# MIME-Version: 1.0 (Generated by Mascot version 1.0)
# Content-Type: multipart/mixed; boundary=gc0p4Jq0M2Yt08jU534c0p
#
# --gc0p4Jq0M2Yt08jU534c0p
# Content-Type: application/x-Mascot; name="parameters"
#
# LICENSE=Licensed to: ---
# MP=
# NM=
# COM=10ftmol BSA
# IATOL=
# IA2TOL=
# IASTOL=
# IBTOL=
# IB2TOL=
# IBSTOL=
# IYTOL=
# IY2TOL=


# REGEXP
# ------
CONSTANT_RESIDUES = re.compile(r'C_term|N_term|[A-Z]')
FIXEDMOD = re.compile(r'^FixedMod\d*$')
FIXMOD_RESIDUES = re.compile(r'^FixedModResidues\d*$')

# CONSTANTS
# ---------
TERMINI = {
    'C_term': 'cterm',
    'N_term': 'nterm'
}


# HELPERS
# -------


@logger.init('matched', 'DEBUG')
class Hits(base.BaseObject):
    '''Convenience class to facilitate adding Mascot search hits to a scan'''

    def __init__(self, modifications, queries):
        super(Hits, self).__init__()

        self.modifications = modifications
        self.queries = queries

    def __call__(self, query, rank, value):
        '''
        Processes the peptide hits to a lists representing each hit
        :
            "1", 0,700.339142,-0.008494,3,SSPPEGK,18,000000000,8.35,
                00000020000000000,0,0;"DAP1_BOVIN":0:2:8:1,"DAP1_HUMAN":
                0:2:8:1,"DAP1_MOUSE":0:2:8:1,"DAP1_RAT":0:2:8:1"
                -> []
        '''

        if value == "-1":
            # null hit
            return []

        hits = []
        peptide_info, proteins_info = value.split(';')
        base_hit = self.process_hit(query, peptide_info.split(','), rank)

        proteins_info = (i.split(':') for i in proteins_info.split(','))
        for protein_info in proteins_info:
            hit = base_hit.copy()
            hit['id'] = ast.literal_eval(protein_info[0])

            # value is already 1-indexed by default, same as ProtProsp
            hit['start'] = int(protein_info[2])

            hits.append(hit)

        return hits

    #     PROCESSOR

    def process_hit(self, query, peptide_info, rank):
        '''Initializes the hit with all the default peptide parameters'''

        hit = {'rank': int(rank)}

        variable_modification_string = peptide_info[6]
        hit['peptide'] = peptide = peptide_info[4]
        hit['modifications'] = self.modifications.process(
            peptide, variable_modification_string)

        # score for  Mascot is defined as -log(p), where p is chance of ion
        # match by chance
        hit['score'] = score = float(peptide_info[7])
        hit['ev'] = 10 ** (-score/10)

        mass = float(peptide_info[1])
        charge = self.queries[query]['z']
        mz_theor = masstools.mz(mass, charge, 0)
        mz_exper = self.queries[query]['mz']
        hit['ppm'] = (mz_theor - mz_exper) * 1e6 / mz_exper

        return hit


@logger.init('matched', 'DEBUG')
class Modifications(base.BaseObject):
    '''Convenience class to facilitate working with Mascot modifications'''

    def __init__(self):
        super(Modifications, self).__init__()

        self.constant_modifications = {}
        self.variable_modifications = sequence.ExtendableList()

    @decorators.overloaded
    def __call__(self, payload):
        '''
        Processes the values from the Mascot masses message, which
        includes modifications, residue and atom masses, etc.

        Need to defined indexed methods for 2 different kind of mods:
        variable and constant:
            Constant Format:
                FixedMod1=57.021464,Carbamidomethyl (C)
                FixedModResidues1=C
            Variable format:
                delta1=15.994915,Oxidation (M)
                delta2=42.010559,N-Acetyl (Protein)

                -> [[15.994915, 'Oxidation (M)'],
                    [42.010559, 'N-Acetyl (Protein)']]
        '''

        for key, value in payload.items():
            if key.startswith('delta'):
                self.set_variablemod(key, value)

            elif FIXEDMOD.match(key):
                # fallthrough, will be parsed the next line
                mass_name = value

            elif FIXMOD_RESIDUES.match(key):
                # mass name always occurs on line preceeding residues
                self.set_constantmod(value, mass_name)

    #     SETTERS

    def set_variablemod(self, key, value):
        '''
        Adds a variable mod to the variable mod lists, using the key
        to acquire the index and the value for modname and mass
        '''

        # delta1 -> 0
        index = int(key[len('delta'):]) - 1
        mass, name = value.split(',')

        mass = float(mass)

        self.variable_modifications[index] = [mass, name]

    def set_constantmod(self, residues, mass_name):
        '''
        Processes a given constant modification, which is comprised of
        2 parts: the mass/name declaration, and the residues declaration
        :
            Mass/name declaration:
                FixedMod1=57.021464,Carbamidomethyl (C)
            Residues declaration:
                FixedModResidues1=C
                    Format, [A-Z]|C_term|N_term, ex. STY
        '''

        for match in  CONSTANT_RESIDUES.finditer(residues):
            residue = match.string
            residue = TERMINI.get(residue, residue)

            mass, name = [i.strip() for i in mass_name.split(',')]
            mass = float(mass)
            # ignore mass temporarily
            self.constant_modifications[residue] = name

    #     PROCESS

    def process(self, peptide, variable_modification_string):
        '''
        Extracts all the constant and variable mods from a given peptide
        sequence, in the following hierarchy
        1. Constant mods by residue counting
        2. Variable mods through the varmod_string
            (all mods treated as certain)
        '''

        modifications = copy.deepcopy(matched.MODIFICATION_TEMPLATE)
        for name, position in self.get_constant_modifications(peptide):
            modifications['certain'][name].append(position)

        for name, position in self.get_variable_modifications(
            variable_modification_string):
            modifications['certain'][name].append(position)

        return modifications

    #     GETTERS

    def get_constant_modifications(self, peptide):
        '''Returns an iterator for all the constant modifications'''

        for index, residue in enumerate(peptide):
            name = self.constant_modifications.get(residue)
            # need to 1-index the mod position
            if name is not None:
                yield (name, index + 1)

        # now need to check terminal positions
        for key, position in TERMINI.items():
            name = self.constant_modifications.get(key)
            if name is not None:
                yield (name, position)

    def get_variable_modifications(self, variable_modification_string):
        '''Adds the variable mods to the mapping holder'''

        length = len(variable_modification_string) - 1
        positions = {0: 'nterm', length: 'cterm'}

        for index, char in enumerate(variable_modification_string):
            if char != '0':
                name = self.variable_modifications[int(char) - 1][1]
                position = positions.get(index, index)
                yield (name, position)


# FORMATTING
# ----------


class QueriesToScans(base.BaseObject):
    '''
    Convenience class to facilitate the processing of Mascot queries
    to direct scan data.
    '''

    def __init__(self, row, ids):
        super(QueriesToScans, self).__init__()

        self.row = row
        self.ids = ids
        self.source = self.app.discovererthread
        engine = self.source.matched.get_engine('matched', row, self.source)
        self.substituter = sequence_variants.SubstitutePlaceholders(engine)

        # debugging helpers
        self.id_counter = 0
        self.noid_counter = 0

    def __call__(self, scan):
        '''Processes all the query data to scans along with formatting'''

        self.substitute_residues(scan)
        self.add_protein_names(scan)
        self.source.matched.data.append_scan(self.row, scan)

    def substitute_residues(self, scan):
        '''
        Substitutes the place-holder residues within the scan, with the
        following conversions
        :
            B -> {'D', 'N'}
            J -> {'L', 'I'}
            X -> set('ACDEFGHIKLMNPQRSTVWY')
            Z -> {'E', 'Q'}
        '''

        hits = scan['hits']
        scan['hits'] = []

        while hits:
            base_hit = hits.pop(0)
            row = scan.torow(base_hit)
            peptides = list(self.substituter(row))
            for index, peptide in enumerate(peptides):

                if not index:
                    # first index only
                    base_hit['peptide'] = peptide
                    scan['hits'].append(base_hit)

                else:
                    hit = base_hit.copy()
                    hit['peptide'] = peptide
                    scan['hits'].append(hit)

    def add_protein_names(self, scan):
        '''Adds the protein name to the given hits for each hit'''

        for hit in scan['hits']:
            id_ = hit['id']
            try:
                hit['name'] = self.ids[id_]
                self.id_counter += 1
            except KeyError:
                hit['name'] = ""
                self.noid_counter += 1


# REGEXP
# ------
PEPTIDE_QUERY = re.compile(r"^q(?P<query>\d*)_p(?P<rank>\d*)$")


# MIME
# ----


class MimeParser(base.BaseObject):
    '''Processes the MIME data from the Mascot MIME format to file'''

    def __init__(self, row, fileobj):
        super(MimeParser, self).__init__()

        # TODO? add decoys?
        source = self.app.discovererthread
        self.data = source.matched[row]
        self.set_messages(fileobj)

        self.queries = mapping.OrderedRecursiveDict()
        self.ids = {}
        self.masses = Modifications()
        self.hits = Hits(self.masses, self.queries)
        self.scans = QueriesToScans(row, self.ids)
        self.title_formatter = scan_titles.TitleFormatter()

    def __call__(self):
        '''On start'''

        self.process_messages()
        self.process_scans()

    def process_messages(self):
        '''Processes all the data from each MIME message to dict'''

        for message in self.messages:
            content = message.get_content_type()
            if content == 'application/x-mascot':
                # {'parameters', 'masses'}
                name = message.get_param('name')
                payload = self.todict(message.get_payload())
                # redundant number of queries, ignore so far
                getattr(self, name, self.query)(payload, name)

    def process_scans(self):
        '''
        Processes all the individual search hits and appends them to
        the matched data
        '''

        # need to add _query_to_data
        for scan in self.queries.values():
            self.scans(scan)

    #     HANDLERS

    @decorators.overloaded
    def parameters(self, payload):
        '''
        Processes the values from the Mascot parameters message,
        which includes parameters such as instrument type, raw file name,
        etc.
        '''

        self.data['attrs']['spectra'] = payload['FILE']
        self.data['attrs']['enzyme'] = payload['CLE']
        self.data['attrs']['search'] = payload['COM']

    @decorators.overloaded
    def header(self, payload):
        '''
        Processes the values from the Mascot header message, which
        includes the search data, Mascot version, and time of search.
        Nothing relevant so a blank method.
        '''

    @decorators.overloaded
    def summary(self, payload):
        '''
        Processes the values from the Mascot summary message,
        which has the following format
        ;
            qmass1=700.330648
            qexp1=351.172600,2+
            qmatch1=4104
            qplughole1=25.536344
            qmass2=700.331048
            qexp2=351.172800,2+

            -> Extract the qexp1, so the query index and the m/z and z
        '''

        for key, value in payload.items():
            if key.startswith('qexp'):
                query = key[len('qexp'):]
                mz, z = value[:-1].split(',')

                self.queries[query] = scan = matched.Scan()
                scan['mz'] = float(mz)
                scan['z'] = int(z)

    @decorators.overloaded
    def peptides(self, payload):
        '''
        Contains all the matched peptides from each query, with the
        Key:
            qn_pm == query(n), peptide hit (m)

        value (Delimiter last char):
             1 -- missed_cleavages ,
             2 -- uncharged, theoretical mass ,
             3 -- mass difference (theor - exper) ,
             4 -- ions matched ,
             5 -- seq ,
             6 -- peaks from ions 1 ,
             7 -- variable mods string ,
             8 -- Peptide Score ,
             9 -- Ion Series ,
            10 -- peaks from ions 2 ,
            11 -- peaks from ions 3 ;
            {
            12 -- Mnemonic UniProt ID :
            13 -- Frame Number :
            14 -- Start :
            15 -- End :
            15 -- Redundancy :
            } -- (repeating n times)
        :
            q1_p1=0,700.325226,0.005422,5,SASHGSR,18,000000000,13.04,
                00020020000000000,0,0;"CYAA_PODAS":0:56:62:1
            q1_p1_terms=R,R
            q1_p2=1,700.343857,-0.013209,5,SAHKCR,18,00000000,11.73,
                00020020000000000,0,0;"GLYR1_ANOGA":0:312:317:1
            q1_p2_terms=R,K
            q1_p3=0,700.325241,0.005407,3,SSSQHR,12,00000000,9.82,
                00010020000000000,0,0;"TRA2_DROVI":0:63:68:1
            q1_p3_terms=K,R
            ...
            q1_p6=0,700.339142,-0.008494,3,SSPPEGK,18,000000000,8.35,
                00000020000000000,0,0;"DAP1_BOVIN":0:2:8:1,"DAP1_HUMAN":
                0:2:8:1,"DAP1_MOUSE":0:2:8:1,"DAP1_RAT":0:2:8:1
            q1_p6_terms=M,L:M,L:M,L:M,L
        '''

        for key, value in payload.items():
            match = PEPTIDE_QUERY.match(key)
            if match is not None:
                query, rank = match.groups()
                self.queries[query]['hits'] += self.hits(query, rank, value)

    @decorators.overloaded
    def proteins(self, payload):
        '''
        Key:
            "Mnemonic" ID
        Value:
            1 -- Molecular Weight
            2 -- Protein Name
        :
            "ZSC12_PONPY"=69983.64,"Zinc finger and SCAN domain-containing
                protein 12 OS=Pongo pygmaeus GN=ZSCAN12 PE=3 SV=1"
            "ZSC12_MACNE"=70047.69,"Zinc finger and SCAN domain-containing
                protein 12 OS=Macaca nemestrina GN=ZSCAN12 PE=3 SV=1"
            "ZSC12_HUMAN"=70177.79,"Zinc finger and SCAN domain-containing
                protein 12 OS=Homo sapiens GN=ZSCAN12 PE=2 SV=1"
        '''

        for id_, value in payload.items():
            # '"ZSC12_PONPY"' -> "ZSC12_PONPY"
            id_ = ast.literal_eval(id_)
            name = ast.literal_eval(value.split(',', 1)[1])
            self.ids[id_] = name

    @decorators.overloaded
    def query(self, payload, name):
        '''
        Key:
            title
        Value:
            urrlib.unquote(orbi_060115_01%2e294%2e294%2e2%2edta)
                ->orbi_060115_01.294.294.2.dta
        :
            title=orbi_060115_01%2e294%2e294%2e2%2edta
            charge=2+
            mass_min=103.350000
            mass_max=673.340000
            int_min=1.1
            int_max=1095
            num_vals=195
            num_used1=-1
            Ions1=182.200000:395.8,
        '''

        if 'IT_MODS' in payload:
            print("Variable mods added for a specific query", file=sys.stderr)
            # not sure if it starts with delta1 or like, delta5
            import pdb, sys; pdb.Pdb(stdout=sys.__stdout__).set_trace()

        query = name[len('query'):]
        title = unquote(payload['title'])
        match = self.title_formatter(title)

        self.queries[query]['fraction'] = match.group('frac')
        self.queries[query]['num'] = int(match.group('num'))

    @decorators.overloaded
    def index(self, payload):
        '''Indexes the byte positions for lower-level parsers, ignore'''

    #     SETTERS

    def set_messages(self, fileobj):
        '''Creates a MIME parser from the file object to parse the data'''

        headers = Parser().parse(fileobj)
        self.messages = headers.walk()

    #     HELPERS

    @staticmethod
    def todict(payload):
        '''
        Converts the plaintext a=b format to a key:value pair
        :
            IBTOL=
            IB2TOL=
            IBSTOL=
            IYTOL=
            IY2TOL=
            ->
                {'IBTOL': '', 'IB2TOL': '', 'IBSTOL': '',
                 'IYTOL': '', 'IY2TOL': ''}
        '''

        items = OrderedDict()
        for row in payload.splitlines():
            key, value = row.split('=', 1)
            items[key] = value

        return items
